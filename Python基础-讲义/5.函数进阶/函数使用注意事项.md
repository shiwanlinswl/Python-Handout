# 函数高级

## 目标

* 局部变量
* 全局变量（重点）
* 在模块中定义函数
* 名片管理系统（重点）
* 不定长参数
* 递归函数
* 引用(重点)
* 可变和不可变类型


## 09. 缺省参数 和 命名参数

### 9.1 缺省参数

* 形参设定默认值 称为 **缺省参数**
* 调用函数时，如果没有传入缺省参数对应的实参，则实参使用默认值。


```python
def printinfo(name, age = 35):
   # 打印任何传入的字符串
   print("Name: %s", % name)
   print("Age: %s", % age)

# 调用printinfo函数
printinfo("miki")
printinfo("miki", 20)
```


* **注意：带有默认值的行参一定要位于参数列表的最后面**。


```python
>>> def printinfo(name, age=35, sex):
...     print name
...
  File "<stdin>", line 1
SyntaxError: non-default argument follows default argument
```


## 9.2 命名参数

调用函数时，**实参可以指定对应的形参**，称为 **命名参数**


```python
def printinfo(name, age):
   # 打印任何传入的字符串
   print("Name: %s", % name)
   print("Age: %s", % age)

printinfo(age=9,name="miki" )
```






## 01. 局部变量

* **局部变量**，就是在 **函数内部定义的变量**
* 不同的函数，可以定义相同的名字的局部变量，但是各用个的不会产生影响
* 局部变量的作用域只在函数内部
* 局部变量的目的是 **存储需要临时保存的数据**

```python
# 函数中的两个局部变量虽然同名，但互不影响
def test1():
    a = 10
    print("%d" % a)


def test2():
    a = 5
    print("%d" % a)

test1()
test2()
```

## 02. 全局变量

### 2.1 概念

* 在函数外边定义的变量叫做 **全局变量**
* 全局变量能够在所有的函数中进行访问

```python
# 定义全局变量
a = 100

def test1():
    print(a)

def test2():
    print(a)

# 调用函数
test1()
test2()
```

### 2.2 函数内修改全局变量

看如下代码:

```python
a = 10

def test():
    a = 5
    print("函数内a：%d" %a)

test()
print("函数外a：%d" %a)
```

* **函数内赋值变量** 时，**默认为定义并赋值局部变量**，赋值后获取的也是局部变量的值
* 如果在函数中修改全局变量，那么就需要使用`global`进行声明，否则出错

```python
a = 10

def test():
    global a
    a = 5  # 修改全局变量
    print("函数内a：%d" %a)

test()
print("函数外a：%d" %a)
```

### 2.3 全局变量命名规范

* 为了方便区分全局变量和局部变量，全局变量可以命名为 `g_变量名`
* 全局变量一般 **定义在文件顶部** 

## 03. 模块

> **模块是 Python 程序架构的一个核心概念**

* **模块** 就好比是 **工具包**，要想使用这个工具包中的工具，就需要 **导入 import** 这个模块
* 每一个以扩展名 `py` 结尾的 `Python` 源代码文件都是一个 **模块**
* 在模块中定义的 **全局变量** 、 **函数** 都是模块能够提供给外界直接使用的工具

### 3.1 第一个模块体验

**步骤**

* 新建 `hm_10_分隔线模块.py`
  * 复制 `hm_09_打印多条分隔线.py` 中的内容，**最后一行 **`print`** 代码除外**
  * 增加一个字符串变量

```python
name = "黑马程序员"
```

* 新建 `hm_10_体验模块.py` 文件，并且编写以下代码：

```python
import hm_10_分隔线模块

hm_10_分隔线模块.print_line("-", 80)
print(hm_10_分隔线模块.name)
```

#### 体验小结

* 可以 **在一个 Python 文件** 中 **定义 变量 或者 函数**
* 然后在 **另外一个文件中** 使用 `import` 导入这个模块
* 导入之后，就可以使用 `模块名.变量` / `模块名.函数` 的方式，使用这个模块中定义的变量或者函数

> **模块**可以让 **曾经编写过的代码** 方便的被 **复用**！

### 3.2 模块名也是一个标识符

* 标示符可以由 **字母**、**下划线** 和 **数字** 组成
* **不能以数字开头**
* **不能与关键字重名**

> 注意：如果在给 Python 文件起名时，**以数字开头** 是无法在 `PyCharm` 中通过导入这个模块的

### 3.3 Pyc 文件（了解）

> `C` 是 `compiled` **编译过** 的意思

**操作步骤**

1. 浏览程序目录会发现一个 `__pycache__` 的目录
2. 目录下会有一个 `hm_10_分隔线模块.cpython-35.pyc` 文件，`cpython-35` 表示 `Python` 解释器的版本
3. 这个 `pyc` 文件是由 Python 解释器将 **模块的源码** 转换为 **字节码**
   * `Python` 这样保存 **字节码** 是作为一种启动 **速度的优化**

**字节码**

* `Python` 在解释源程序时是分成两个步骤的  
    1. 首先处理源代码，**编译** 生成一个二进制 **字节码**  
    2. 再对 **字节码** 进行处理，才会生成 CPU 能够识别的 **机器码**

* 有了模块的字节码文件之后，下一次运行程序时，如果在 **上次保存字节码之后** 没有修改过源代码，Python 将会加载 .pyc 文件并跳过编译这个步骤

* 当 `Python` 重编译时，它会自动检查源文件和字节码文件的时间戳

* 如果你又修改了源代码，下次程序运行时，字节码将自动重新创建

> 提示：有关模块以及模块的其他导入方式，后续课程还会逐渐展开！
>
> **模块是 Python 程序架构的一个核心概念**

## 04. 名片管理系统

* 见 **学生管理系统** 一章

## 05. 不定长参数

> 需求： 参数数量不确定，能否接收？

### 5.1 args

* 函数可以定义 **不定长参数**，**用于接收任意多数量的参数**
* **不定长参数的前边需要添加***，用于提示python解释器该参数为不定长参数
* 使用不定长参数直接用args即可（不需要加*）
* 不定长参数的本质是 **将传递的参数包装成了元组**

```python

def sum_num(a, b, *args):  
    result = a + b
    for temp in args:
        result += temp
        
    return result
        
sum_num(1, 2, 3, .., n)

# 命名参数一旦使用，所有实参都要使用，除非该实参为不定长参数
# sum_num(1, 2, 3, 4, a=5)
# sum_num(a=5, b=4)

```

### 5.2 kwargs

* 不定长参数还有一种形式 **可以接收不存在的命名参数**
* 定义参数时需要在变量名前添加两个*
* 这种不定义参数会将 **不存在的命名参数包装成字典**

```python

def sum_num(a, b, *args, **kwargs):  
    print(a)
    print(b)
    print(args)
    print(kwargs)
        
sum_num(1, 2, 3, .., n, mm=5, nn=6)

```

### 5.3 传递不定长参数

* 如果 **将不定长参数传递给其他函数**，**则需要在不定长参数前添加对应的***，才能正常传递


```python

def sum_num(a, b, *args, **kwargs):  
    print(a)
    print(b)
    print(args)
    print(kwargs)
    test(*args, **kwargs)


def test(*args, **kwargs):
    print(args)
    print(kwargs)
                    
sum_num(1, 2, 3, .., n, mm=5, nn=6)

```

## 06. 递归函数

* 通过前面的学习知道一个函数可以调用其他函数。

* 如果 **一个函数在内部调用其本身**，这个函数就是 **递归函数**。

* 递归函数的作用
举个例子，我们来计算阶乘 n! = 1 * 2 * 3 * ... * n

解决办法1:

#### 看阶乘的规律
```

1! = 1  
2! = 2 × 1 = 2 × 1!  
3! = 3 × 2 × 1 = 3 × 2!  
4! = 4 × 3 × 2 × 1 = 4 × 3!  
...  
n! = n × (n-1)!    # 如果定义step_num函数实现了阶乘，相当于step_num(n) = n * step_num(n-1)
```
```


def step_num(num):
    if num > 1:
        return num * step_num(num - 1)
    else:
        return 1
```
* 递归函数一般都需要一个条件判断来打破死循环,否则会导致到达最大嵌套次数，程序报错


## 07. 引用

* python中可以使用 **id函数查看引用的是否为同一个内存空间**，如果返回值相同，说明引用相同

* 在python中，**值是靠引用来传递的**。

```python
>>> a = 1
>>> b = a
>>> id(a) 
13033816
>>> id(b)   # 注意两个变量的id值相同
13033816
>>> a = 2
>>> id(a)   # 注意a的id值已经变了
13033792
>>> id(b)   # b的id值依旧
13033816
```

```python
>>> a = [1, 2]
>>> b = a
>>> id(a)
139935018544808
>>> id(b)
139935018544808
>>> a.append(3)
>>> a
[1, 2, 3]
>>> id(a)
139935018544808
>>> id(b)       # 注意a与b始终指向同一个地址
139935018544808
```

### 可变类型与不可变类型

可变类型，值可以改变：

* 列表 list
* 字典 dict

不可变类型，值不可以改变：

* 数值类型 int, long, bool, float
* 字符串 str
* 元组 tuple



